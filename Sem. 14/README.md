# Дървовидна структура от обекти от полиморфна йерархия.

Искаме да реализираме клас за работа с произволни логически изрази. Искаме да имаме функции, за:

 - Проверка дали израз е тавтология
 - Проверка дали израз е противоречие
 - Създаване на такъв израз по стринг


## Представяне в паметта
Всеки логически израз е:

 - Променлива
 - Бинарна операция, която има ляв логически израз и десен логически израз
 - Унарна операция, която има друг логически израз

![enter image description here](https://i.ibb.co/nrfpbmY/68747470733a2f2f692e6962622e636f2f747359486a524e2f556e7469746c65642d4469616772616d2d64726177696f2d32.png)

## Пресмятане на стойност на израз
За да пресметнем стойност на израз ни трябва **булева интерпретация** (оценка на всяка участваща променлива).  За това въвеждаме чисто виртуална функция **evaluate**.
Тази функция ще се изпълнява по различен начин от трите вида изрази

 - Променливата ще връща оценката от интерпретацията
 - Унарната операция ще оцени своя подизраз и спрямо операцията ще върне резултат.
 - Бинарната операция ще оцени двата свои подизрази и спрямо операцията ще върне резултат.

! Един логически израз е тавтология, когато за произволна/всяка булева интерпретация той се оценява като истина. !

## Променливите, участващи в логическите изрази

При построяването на всеки израз ще пазим кои променливи участват. Отново това става по различен начин за трите вида изрази.

 - В променливата участва само една променлива (самата тя).
 - В унарната операция участват точно тези променливи, които участват в подизраза
 - В бинарната операция участват променливите от левия израз и променливите от десния израз (тяхното обединение)

![enter image description here](https://i.ibb.co/frMd5HL/Untitled-Diagram2-drawio-1.png)

Имайки **променливите и техния брой**, лесно можем да г**енерираме всички булеви интерпретации** за тях и да проверим дали израза е **тавтология** или **противоречие**.

## Създаване на такъв израз по стринг

За да избегнем въвеждането на приоритет и прилагането на алгоритми като Shunting yard, ще въвеждаме изразите **със скоби около всяка операция**.
Примерен такъв стринг: (((PvQ)^(TvR))v(!P)).

Как да разберем коя операция се прилага първа? 
- Премахваме първата и последната скоба
- Обхождаме стринга и използваме брояч. При срещането на отваряща скоба увеличаваме брояча с 1, а при срещането на затваряща - намаляваме броята с 1.
- Символът за опрацията, който срещнем когато броячът има стойност 0, е точно операцията, която трябва да се приложи първа. За аргументите на операцията извикваме същатата функция рекурсивно.

![enter image description here](https://i.ibb.co/xFrVxsG/Untitled-Diagram2-drawio-2-1.png)


### Задача
Реализирайте клас за работа с изрази от множества. Трябва да имате:

- Функция за парсване на израз от стринг.
- Функция, която приема елемент и връща дали елементът е част от полученото от израза множество
- Функция, която приема 2 израза и връща дали се получава едно и също множество.

 ```c++
int main()
{
	//v - union
	//^ - intersection
        // '\' - set minus
        // '!' - complement
        // 'x' - relative complement

	SetCalculator s("(((A^B)vC)vX)");

	SetExpression::Element el;
	el.set('A', true); //element is in set A
	el.set('B', false); // element is NOT in set B
	el.set('C', true); // element is in set C

	std::cout << s.isElementIn(el);

        SetCalculator s1("(A^B)");
        SetCalculator s2("(!((!A)v(!B)))");
        s1 == s2; // true (De morgan laws)
}
 ```

