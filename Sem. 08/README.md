# Композиция на обекти. Масиви от обекти.
## Композиция
Композиция – класове като елементи на други класове (влагане на класове). <br/>
Един клас може да включва в себе си обекти от други класове като член-данни. <br/> 
Когато обект от даден клас се дефинира, автоматично се извиква неговият конструктор. <br/> 
Ако класът съдържа член-данни, в неговия конструктор трябва да се укаже кои конструктори на член-данните да се извикват. <br/> 

#### Пример 1
```c++
class A
{
 .
 .
 .
}
class B
{
	 int n;
	 A obj;
}
 ```
В тази ситуация се извикват **default-ните конструктори на n и obj**. <br/> 

#### Пример 2
```c++
class A
{
	A(int a, int b)
 .
 .
 .
}
class B
{
	B() : obj(1, 2)
	{}
	
	int n;
	A obj;
}
 ```
Тук A няма default-ен конструктор. Това означава, че в конструктора на B трябва да се извика **експлицитно** някой от неговите конструктори. <br/>

### Композиция на обекти с динамична памет
Когато имаме композиция и в главния клас има динамично заделяне на памет, то трябва в реализацията на копи-конструктора и оператор=  **експлицитно** да се извикват копи-конструкторите и оператора = за всички член-данни (композирани обекти). 
```c++
class B;

class A
{
	void copyFrom(const A& other)
	{
		arr = new int[other.size];
		for (size_t i = 0; i < other.size; i++)
			arr[i] = other.arr[i];
		size = other.size;
	}
	void free()
	{
		delete[] arr;
	}

public:
	B nestedObject;
	int* arr; //dynamic array
	size_t size; 
  
	A(int n) : size(n)
	{
		arr = new int[n];
	}
	A(const A& other) : nestedObject(other.objTest), size(other.size)
	{
		copyFrom(other);
	}
	A& operator=(const A& other)
	{
		if (this != &other)
		{
			nestedObject= other.nestedObject;
			free();
			copyFrom(other);
		}
		return *this;
	}

	~A()
	{
		free();
	}
};
 ```
**ВАЖНО**: Деструкторите на член-данните **НЕ** трябва да се извикват експлицитно в деструктора на класа.

## Масиви от обекти
#### Статичен масив от обекти
```c++
class A;
int main()
{
	A arr[5]; //5 def. constr.
} //5 destr
 ```
Създава **статичен** масив с 5 обекта от тип A. На всеки от тях се е извикал конструктора по подразбиране.
Масивът ще се изтрие, когато приключи функцията. <br/>

#### Статичен масив от указатели към обекти
```c++
class A;
int main()
{
	A* arr[5]; //5 empty pointers.
	
	arr[0] = new A();
	arr[2] = new A();
	
	delete arr[0];
	delete arr[2];
}
 ```
Създава **статичен** масив с 5 указателя . Само на 2 от тези указатели присвояваме обекти, които са заделени в динамичната памет.
Масивът ще се изтрие, когато приключи функцията. <br/> 

#### Динамичен масив от обекти
```c++
class A;
int main()
{
	A* arr = new A[5]; //5 def constr.
	delete[] arr; //5 destr
} 
 ```
Създава **динамичен** масив с 5 обекта от тип A. На всеки от тях се е извикал конструктора по подразбиране.
Масивът ще се изтрие (и ще се изтрият обектите), когато се извика delete[] върху него.

#### Динамичен масив от указатели към обекти
```c++
class A;
int main()
{
	A** arr = new A*[5]; //5 empty pointers.
	
	arr[0] = new A(); //def constr. 
	arr[2] = new A(); //def constr.
	
	delete arr[0]; //destr.
	delete arr[2]; //destr.
	
	delete[] arr;
}
 ```
Създава **динамичен** масив с 5 указателя . Само на 2 от тези указатели присвояваме обекти, които са заделени в динамичната памет.
Масивът ще се изтрие (и без да се изтрият обектите), когато се извика delete[] върху него. Заделените обекти трябва да се изтрият отделно.
