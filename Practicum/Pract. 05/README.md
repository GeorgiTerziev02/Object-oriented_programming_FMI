## Задача 1. 
Да се напише клас Вафла, която има

* марка - низ до 20 символа
* грамаж
* цена на едро
* цена за краен клиент
Да се опише Магазин за вафли, който има в себе си:

* масив от вафли
* максимален брой вафли
* приходи до момента
* разходи до момента

Напишете функции, които да позволяват следните действия:

* Продава се вафла по дадена марка
* Купуват се n вафли от склада на дадена марка
* Показва колко вафли има от дадена марка
* Показва печалбата до момента

## Задача 2. 
Ще реализираме проста система за купуване и продаване на различни продукти.

При работата с тази система е възможно да възникнат различен тип грешки. Ще използваме следния Enum за да връщаме описателно грешките:

``` c++
enum class State {
    OK,
    NegativeBalance,
    NegativeQuantity,
    UserFull,
    ProductFull,
    PriceFull,
    UserNotFound,
    ProductNotFound,
    ShortOnMoney,
    NotEnoughItems
};
```
Клас представящ потребител (User).

Член-данни:
* size_t id - Индекс на потребителя. Никой потребител няма id = 0.
* char[32] name - Име с дължина 32 символа.
* double balance - Парите с които разполага.

Класът трябва да има:
* Конструктор по подразбиране (слагат се default стойности на член-данните като id = 0).
* Конструктор с параметри.
* State updateMoney(double factor); - Добавя factor към парите. factor може и да е отрицателен. Парите никога обаче не са отрицателни. Ако парите стават отрицателни се връща грешка  NegativeBalance и промяната не се отбелязва.
* bool hasMoney(double arg); - Връща дали потребителя има достатъчно пари.
* size_t getID - Връща индекса на потребителя

Клас представляващ продукс (Product):

Член-данни:
* char[32] name - Име на продукта.
* size_t ownedId - id на притежателя му.
* size_t quantity - Колко бройки от този продукт притежаваме
* size_t productId - Индекс на продукта. Никой продукт няма индекс 0.

Класът трябва да има:
* Конструктор по подразбиране.
* Конструктор с параметри
* size_t getQuantity - връща колко бройки има.
* State updateQuantity(int amount) - променя броя на продуктите. Броя на продуктите никога не е по - малък от 0. Ако след промяната продуктите стават по - малко от 0 се връща грешка 
NegativeQuantity и промяната не се отбелязва.
* size_t getProductID - връща индекса на продукта
* size_t getOwnerID - връща индекса на притежателя.

Клас пазещ цените на продуктите (Price):

Член-данни:
* size_t productId - Индекс на продуктът.
* double price - Цена
Класът трябва да има:
* Конструктор по подразбиране. Отново слага productId = 0.
* Конструктор с параметри.
* double getPrice - Връща цената.
* size_t getId - Връща productId
* State updatePrice(double amount) - Добавя amount към price. Ако price става по - малко от 0 фуннкцията връща NegativePrice и промяната не се отбелязва.

Клас, пазещ информация за потребителите в системата (UsersDatabase):

Член-данни:
* user[50] users - Статичен масив пазещ всички потребители
* size_t size - Броя на потребителите до момента

Класът трябва да има:
* Конструктор по подразбиране - създава празна база.
* State addUser - Добавя потребител в базата. Всеки потребител в базата има уникално id. Ако потребителите стават повече от капацитета се враща UserFull
* bool hasEnoughMoney(id, money) - проверява дали потребител с този индекс има достатъчно пари.
* Други помощни функции (bool existUser...)

Клас, пазещ информация за продуктите в системата (ProductsDatabase):

Член-данни:
* Product[50] products - Статичен масив пазещ всички потребители
* size_t size - Броя на потребителите до момента
Класът трябва да има:
* Конструктор по подразбиране - създава празна база.
* State addProduct(name, id, prodID, quantity) - Добавя продукт в базата. Всеки продукт в базата има уникално productId. ID-то на потребителя се приема като аргумент. Ако превишим броя на продуктите се връща ProductFull.
* size_t itemsOwned(id, productID) - връща колко бройки от даден продукт притежава даден потребител.
* State update(id, productID, update) - променя колко бройки притежава даден потребител (в случай че продаде нещо или купи)
* Други помощни функции (existProduct...)

Клас, пазещ информация цените на продуктите (PricesDatabase):

Член-данни
* price[50] prices - Статичен масив пазещ всички цена
* size_t size - Броя на цени до момента
Класът трябва да има:
* Конструктор по подразбиране - създава празна база.
* State addPrice - Добавя цена в базата. Ако превишим броя на цените се връща PriceFull.
* double getPrice(id) - Връща цената на продукт по подадено id.

Използвайки тези класове ще реализираме клас SalesSystem.

Член-данни:
* UsersDatabase users - Пази информация за потребителите в системата.
* ProductsDatabase products - Пази информация за продуктите в системата.
* PricesDatabase prices - Пази информация за цените на продуктите в системата.
Класът трябва да поддържа:
* Конструктор по подразбиране - създава празна система.
* Функция за добавяне на потребител в базата.
* Функция за добавяне на продукт в базата. Няма как да добавим продукт ако той няма собственик. Ако ownerID не се съдържа в users добавянето е неуспешно и се връща UserNotFound.
* Функция за добавяне на цена на продукт в базата. Цената няма как да е отрицателна. Няма смисъл да пазим цени за които няма продукти. Ако при добавяне на цена продукта не съществува добавянето е неуспешно и се връща ProductNotFound.
И най - важната функция, тази чрез която продаваме:

```c++
State sell(size_t idFrom, size_t idTo, size_t productID, size_t quantity)
```

При продаването е възможно да се случат няколко грешки:

* Някой от потребителите не съществува. Връща се UserNotFound грешка
* Продукта не съществува. Връща се ProductNotFound грешка.
* Потребителя, който купува да няма пари. Връща се ShortOfMoney грешка.
* Потребителя, който продава да няма толкова неща. Връща се NotEnoughItems грешка

Ако за продукта няма цена цената му се приема за 0.

Парите се въртят по стандартния начин. Потребителя който купува губи цената на продукта * броя на продукта. Симетрично, този който продава печели същата сума.

В базата данни за продуктите броя на притежаваните от продавача продукти се намаля а броя на притежаваните от купувача продукти се уваличава (ако съществува. Ако не се добавя).